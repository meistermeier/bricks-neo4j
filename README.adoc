= Bricks4j

_A brick database in Neo4j._

Besides having a whole catalog of a well-known brick company, the idea is to ask the database what one could build with a given set.

== Data import

Data comes from https://rebrickable.com/downloads/
At the moment only

* sets
* inventories
* parts
* colors
* inventory_parts
* elements

are needed.
Also have a look at the schema given on the page to get an impression of the data and the relationships in there.

=== Clean up

Yes, I copy my own script from here ;)

[source,cypher]
----
MATCH (n) detach delete n;
DROP INDEX Inventory_Id;
DROP INDEX Part_Number;
DROP INDEX Element_Id;
DROP INDEX Color_ColorId;
DROP INDEX Set_Number;
DROP INDEX PartGroup_InventoryIdAndPartNumber;
DROP INDEX PartGroup_InventoryIdAndPartNumberColorIdIsSpare;
----

=== Indexes

To get a better performance when creating the relationships, we create some indexes upfront.

[source,cypher]
----
CREATE INDEX Inventory_Id FOR (i:Inventory) on (i.inventoryId);
CREATE INDEX Part_Number FOR (p:Part) on (p.partNumber);
CREATE INDEX Color_ColorId FOR (c:Color) on (c.colorId);
CREATE INDEX Set_Number FOR (s:Set) on (s.number);
CREATE INDEX Element_Id FOR (e:Element) on (e.elementId);

// composite index only available in Neo4j Enterprise
// btw. did you try Neo4j Desktop with built-in Neo4j Enterprise edition? https://neo4j.com/download/
CREATE INDEX PartGroup_InventoryIdAndPartNumber FOR (pg:PartGroup) on (pg.inventoryId, pg.partNumber);
CREATE INDEX PartGroup_InventoryIdAndPartNumberColorIdIsSpare FOR (pg:PartGroup) on (pg.inventoryId, pg.partNumber, pg.colorId, pg.isSpare);
----

=== Import script
[source,cypher]
----
USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///sets.csv' AS set
CREATE (:Set{number: set.set_num, name: set.name, year: toInteger(set.year), numberOfParts: toInteger(set.num_parts)});

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///inventories.csv' AS inventory
CREATE (i:Inventory{inventoryId: toInteger(inventory.id)});

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///parts.csv' AS part
CREATE (p:Part{partNumber: part.part_num, name: part.name});

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///colors.csv' AS color
CREATE (:Color{colorId: toInteger(color.id), name: color.name, rgb: color.rgb, transparent: CASE color.is_trans when 'f' then false else true end});

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///inventory_parts.csv' AS inventory_parts
CREATE (pg:PartGroup{inventoryId: toInteger(inventory_parts.inventory_id), partNumber: inventory_parts.part_num, isSpare: CASE inventory_parts.is_spare when 'f' then false else true end, colorId: toInteger(inventory_parts.color_id)});

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///elements.csv' AS elements
CREATE (e:Element{elementId: elements.element_id, partNumber: elements.part_num});

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///inventories.csv' AS inventory
MATCH (s:Set{number: inventory.set_num})
MATCH (i:Inventory{inventoryId: toInteger(inventory.id)})
MERGE (s)-[:DEFINED_BY]->(i);

// To get a unique node for the relationship creation later, we need to set colorId as a property.
USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///inventory_parts.csv' AS inventory_parts
MATCH (pg:PartGroup{inventoryId: toInteger(inventory_parts.inventory_id), partNumber: inventory_parts.part_num, colorId: toInteger(inventory_parts.color_id), isSpare: CASE inventory_parts.is_spare when 'f' then false else true end})
MATCH (i:Inventory{inventoryId: toInteger(inventory_parts.inventory_id)})
CREATE (i)-[:NEEDS]->(pg);

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///inventory_parts.csv' AS inventory_parts
MATCH (pg:PartGroup{inventoryId: toInteger(inventory_parts.inventory_id), partNumber: inventory_parts.part_num, colorId: toInteger(inventory_parts.color_id), isSpare: CASE inventory_parts.is_spare when 'f' then false else true end})
MATCH (c:Color{colorId: toInteger(inventory_parts.color_id)})
CREATE (pg)-[:HAS_COLOR]->(c);

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///inventory_parts.csv' AS inventory_parts
MATCH (pg:PartGroup{inventoryId: toInteger(inventory_parts.inventory_id), partNumber: inventory_parts.part_num, colorId: toInteger(inventory_parts.color_id), isSpare: CASE inventory_parts.is_spare when 'f' then false else true end})
MATCH (p:Part{partNumber: inventory_parts.part_num})
CREATE (pg)<-[:IS_PART_OF{quantity: toInteger(inventory_parts.quantity)}]-(p);

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///elements.csv' AS elements
MATCH (e:Element{elementId: elements.element_id})
MATCH (p:Part{partNumber: elements.part_num})
CREATE (p)-[:IS]->(e);

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///elements.csv' AS elements
MATCH (e:Element{elementId: elements.element_id})
MATCH (c:Color{colorId: toInteger(elements.color_id)})
CREATE (e)-[:HAS_COLOR]->(c);

USING PERIODIC COMMIT 2000 LOAD CSV WITH HEADERS FROM 'file:///parts.csv' AS part
MATCH (p:Part{partNumber: part.part_num, name: part.name})
MERGE (m:Material{material: part.part_material})
MERGE (p)-[:MADE_OF]->(m);

----

=== To do

* Part relationships (parent-child)
* Minifigs (like Super Mario etc.)
* Part categories
* Themes

== Exploring the dataset

=== Verify description and parts defined by relationships

Compare number of parts to the set description.

[source,cypher]
----
MATCH (s:Set)-[:DEFINED_BY]->(:Inventory)-[:NEEDS]->(pg:PartGroup)<-[r:IS_PART_OF]-(:Part)
WHERE s.name =~ ".* Dodge Charger" AND NOT pg.isSpare 
RETURN s.name, s.numberOfParts, sum(r.quantity);
----

result

|===
| s.name | s.numberOfParts | sum(r.quantity)

| "Domâ€™s Dodge Charger" | 1077 | 1077
|===

=== Spare parts of a set

Quantity and part number of spare parts.

[source,cypher]
----
MATCH (s:Set)-[:DEFINED_BY]->()-[:NEEDS]->(pg:PartGroup{isSpare:true})<-[pr:IS_PART_OF]-(:Part)
WHERE s.number = "42088-1" 
RETURN pr.quantity, pg.partNumber;
----

result

|===
| pr.quantity | pg.partNumber

| 1 | "4274"
| 1 | "32123b"
| 1 | "6141"
| 1 | "6141"
| 1 | "54200"
| 1 | "6141"
| 1 | "58176"
| 1 | "2780"
|===

=== Parts to elements

It is important to understand that a `Part` defined in the `PartGroup` is not matching a specific "part number" in the manual.
Those are more generic numbers that may be defined in various versions (like an _a_ or _b_ suffix).
To match the real number given in the manual, we are using also the `Element` types.
Those are mapping part numbers (logical number) to element ids (the physical thing, let's call them bricks).
Since the physical parts are colored there are at least one element id for every color the part is available in.

For a _Technic Bush 1/2 Smooth with Axle Hole Semi-Reduced_ (32123b) this would be:
[source,cypher]
----
MATCH (e:Element)-[:HAS_COLOR]->(c:Color)
WHERE e.partNumber = "32123b"
RETURN e.partNumber, e.elementId, c.name;
----

result

|===
| e.partNumber | e.elementId | c.name

| "32123b" | "4110050" | "Light Gray"
| "32123b" | "4211573" | "Light Bluish Gray"
| "32123b" | "6271167" | "Yellow"
| "32123b" | "3212324" | "Yellow"
| "32123b" | "6271165" | "Light Bluish Gray"
|===

This basically means that the bricks are interchangeable.
Of course even better if there are two bricks for the same part number sharing the same color.

== GDS (WIP)

Here is an https://github.com/meistermeier/bricks4j/blob/main/gds.adoc[example] how to apply PageRank provided by the Neo4j GDS library on the `Part` nodes to find out which of them are the most used ones.

== Next

* Complete the import and information gathering around the missing elements.
* Create custom inventory that contains parts to match against existing sets.
** This will enable the functionality to determine how many sets can be built with your home inventory.
* Try to calculate the missing parts between the custom inventory and the chosen set.
* Define fallback part definitions that would enable building a model 100% even if not 100% of the defined parts in a set exist in the custom inventory.
** Ignore colors
** Physical replacement: e.g. 2x2 could be a replacement for a 1x4 brick